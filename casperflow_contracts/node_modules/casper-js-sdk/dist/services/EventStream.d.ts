import EventSource from 'eventsource';
import { Result } from 'ts-results';
export interface DeploySubscription {
    deployHash: string;
    eventHandlerFn: EventHandlerFn;
}
/**
 * @deprecated
 */
declare enum StreamErrors {
    NotAnEvent = 0,
    EarlyEndOfStream = 1,
    MissingDataHeader = 2,
    MissingDataHeaderAndId = 3,
    MissingId = 4
}
export declare class DeployWatcher {
    eventStreamUrl: string;
    es: EventStream;
    watchList: DeploySubscription[];
    constructor(eventStreamUrl: string);
    subscribe(val: DeploySubscription[]): void;
    unsubscribe(deployHash: string): void;
    start(): void;
    stop(): void;
}
type EventHandlerFn = (result: any) => void;
export declare enum EventName {
    /** Can be fetched in `/events/main` path */
    BlockAdded = "BlockAdded",
    /** Can be fetched in `/events/main` path */
    DeployProcessed = "DeployProcessed",
    /** Can be fetched in `/events/deploys` path */
    DeployAccepted = "DeployAccepted",
    BlockFinalized = "BlockFinalized",
    /** Can be fetched in `/events/sigs` path */
    FinalitySignature = "FinalitySignature",
    Fault = "Fault"
}
interface EventSubscription {
    eventName: EventName;
    eventHandlerFn: EventHandlerFn;
}
export interface EventParseResult<E = unknown> {
    id: string;
    /** @deprecated */
    err?: StreamErrors | null;
    body: E;
}
export declare class EventStream {
    eventStreamUrl: string;
    subscribedTo: EventSubscription[];
    eventSource: EventSource;
    constructor(eventStreamUrl: string);
    subscribe(eventName: EventName, eventHandlerFn: EventHandlerFn): Result<boolean, string>;
    unsubscribe(eventName: EventName): Result<boolean, string>;
    private runEventsLoop;
    start(eventId?: number): void;
    stop(): void;
}
export {};
